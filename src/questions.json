[
  {
    "topic": "Explain Cross‑Site Scripting (XSS)",
    "category": "Web Security",
    "answer": "<p><strong>Cross‑Site Scripting (XSS)</strong> is a class of web vulnerability where an attacker injects malicious client‑side scripts into web pages viewed by other users. The injected script runs in the victim’s browser in the context of the vulnerable site, allowing the attacker to steal cookies, hijack sessions, perform actions as the user, deface pages, or deliver malware.</p>\n\n<p><strong>Types</strong></p>\n<ul>\n  <li><strong>Reflected XSS</strong>: Malicious payload is part of a request (URL, form); the server echoes it back in the response. Often delivered via phishing links.</li>\n  <li><strong>Stored (Persistent) XSS</strong>: Payload is saved on server side (database, forum post, comment) and served to every user who views the content.</li>\n  <li><strong>DOM‑based XSS</strong>: Client‑side JavaScript manipulates the DOM using unsafe data (location.hash, document.write, innerHTML) causing execution without server involvement.</li>\n</ul>\n\n<p><strong>Impact</strong>: session theft, account takeover, CSRF amplification, keylogging, phishing within site, pivoting to internal functionality.</p>\n\n<p><strong>Prevention (defense‑in‑depth)</strong></p>\n<ul>\n  <li><strong>Output encoding</strong>: Encode data for the exact context where it’s rendered — HTML escape (&lt;, &gt;, &amp;, &quot;), attribute encoding, JavaScript escaping, URL encoding.</li>\n  <li><strong>Input validation</strong>: Validate length/type server‑side, but do not rely on it for XSS prevention (use encoding).</li>\n  <li><strong>Use safe APIs</strong>: Avoid <code>innerHTML</code>, <code>document.write</code> and string building for DOM. Prefer DOM methods that set text content (e.g., <code>textContent</code>) or template engines that auto‑escape.</li>\n  <li><strong>HTTPOnly cookies</strong>: Mark session cookies <code>HttpOnly</code> so scripts cannot read them (mitigates theft, not execution).</li>\n  <li><strong>Content Security Policy (CSP)</strong>: Limit allowed script sources; use CSP to block inline scripts and reduce attack surface (note: CSP is a mitigation, not a replacement for encoding).</li>\n  <li><strong>Sanitization libraries</strong>: For HTML allowed input (e.g., rich text), sanitize with well‑maintained libraries instead of ad‑hoc regex.</li>\n  <li><strong>Framework protections</strong>: Modern frameworks (React, Angular, Vue) auto‑escape by default if used properly; prefer binding mechanisms not raw HTML insertion.</li>\n</ul>\n\n<p><strong>Testing</strong>: Use automated scanners, manual payloads (e.g., <code>&lt;script&gt;alert(1)&lt;/script&gt;</code>), and pay special attention to URL parameters, form inputs, comment fields, file names, and any place user input is reflected.</p>",
    "grade": 0
  },
  {
    "topic": "Explain Cross‑Site Request Forgery (CSRF)",
    "category": "Web Security",
    "answer": "<p><strong>Cross‑Site Request Forgery (CSRF)</strong> tricks a victim’s browser into sending authenticated requests to a web application where the victim is logged in. Because the browser automatically attaches cookies/credentials, these forged requests appear valid to the server and can cause actions (change email, make payments, delete data).</p>\n\n<p><strong>How it works</strong>: Attacker crafts a request (form submission, image src, fetch) that issues a state‑changing action on the target site. If the victim visits the attacker page while logged in to the target, the browser will send the victim’s cookies and the action succeeds.</p>\n\n<p><strong>Typical example</strong>:</p>\n<pre><code>&lt;form action=\"https://bank.example/transfer\" method=\"POST\"&gt;\n  &lt;input type=\"hidden\" name=\"amount\" value=\"1000\" /&gt;\n  &lt;input type=\"hidden\" name=\"to\" value=\"attacker\" /&gt;\n  &lt;input type=\"submit\" value=\"Click me\" /&gt;\n&lt;/form&gt;</code></pre>\n\n<p><strong>Defenses</strong></p>\n<ul>\n  <li><strong>Anti‑CSRF tokens</strong>: Issue a random token per user/session and require it as a hidden form field or custom header. Server validates token on state‑changing requests. Use double submit or server‑stored tokens.</li>\n  <li><strong>SameSite cookies</strong>: Set session cookies with <code>SameSite=Lax</code> or <code>SameSite=Strict</code> so cross‑site requests omit cookies in many cases.</li>\n  <li><strong>Check Origin/Referer headers</strong>: Validate the Origin or Referer header for sensitive requests (works for browsers that send them).</li>\n  <li><strong>Use custom request headers</strong>: Ajax requests with custom header (e.g., <code>X‑Requested‑With</code>) cannot be forged by plain HTML forms and require CORS authorization.</li>\n  <li><strong>Require re‑auth for critical actions</strong>: Prompt for password or 2FA for high‑impact operations.</li>\n</ul>\n\n<p><strong>Difference from XSS</strong>: CSRF abuses a user’s authenticated browser to send requests (server trust in cookies), while XSS runs attacker scripts in the victim’s browser and can bypass many defenses (e.g., steal tokens, perform CSRF-like actions but with JavaScript power).</p>\n\n<p><strong>Testing & implementation notes</strong>: Ensure tokens are unpredictable, tied to a session, and validated server‑side. Do not use only security through obscurity (e.g., hidden fields without server validation).</p>",
    "grade": 0
  },
  {
    "topic": "Explain SQL Injection (SQLi)",
    "category": "Ethical Hacking / Web Security",
    "answer": "<p><strong>SQL Injection (SQLi)</strong> occurs when untrusted input is included directly in SQL queries, allowing an attacker to change the structure of the query. This can lead to data exfiltration, unauthorized data modification, authentication bypass, or full system compromise.</p>\n\n<p><strong>Common types</strong></p>\n<ul>\n  <li><strong>Error‑based SQLi</strong>: Triggers errors that reveal database structure or data.</li>\n  <li><strong>Union‑based SQLi</strong>: Uses <code>UNION SELECT</code> to combine attacker‑controlled rows with legitimate query results.</li>\n  <li><strong>Blind SQLi (Boolean)</strong>: No direct output; infer data by true/false responses to crafted payloads.</li>\n  <li><strong>Time‑based Blind</strong>: Use database sleep/time functions to infer data via response delays.</li>\n</ul>\n\n<p><strong>Example vulnerability (pseudo‑JS)</strong>:</p>\n<pre><code>const query = \"SELECT * FROM users WHERE username = '\" + input + \"'\";\n// If input = \"' OR '1'='1\", query becomes: SELECT * FROM users WHERE username = '' OR '1'='1'\n</code></pre>\n\n<p><strong>Prevention (best practices)</strong></p>\n<ul>\n  <li><strong>Parameterized queries / prepared statements</strong>: Use placeholders and bind variables — this separates code from data (works for SQL libraries in all languages).</li>\n  <li><strong>Use ORMs</strong> or safe query builders that parameterize automatically.</li>\n  <li><strong>Input validation</strong>: Enforce expected types/lengths; for numeric IDs, cast/validate before use.</li>\n  <li><strong>Least privilege</strong>: Database user should have minimum rights (e.g., no schema changes, limited SELECT/INSERT/UPDATE).</li>\n  <li><strong>Stored procedures</strong>: When used correctly with parameterization they can reduce risk, but are not a guarantee if they perform dynamic SQL.</li>\n  <li><strong>Escape when absolutely needed</strong>: If concatenation is unavoidable, escape properly for the DB engine — but prefer parameterization.</li>\n  <li><strong>WAF / logging / monitoring</strong>: Detect injection patterns and anomalous queries for defense in depth.</li>\n</ul>\n\n<p><strong>Testing</strong>: Use automated scanners (sqlmap for black‑box), manual payloads, blind testing techniques, and review database logs for suspicious commands. Pay attention to all user inputs, headers, cookies, and API parameters.</p>",
    "grade": 0
  },
  {
    "topic": "tcpdump — capture and inspect network traffic",
    "category": "System / Network Admin",
    "answer": "<p><strong>tcpdump</strong> is a command‑line packet analyzer that captures network traffic from an interface and displays or writes packets. It's invaluable for diagnosing network problems, analyzing protocols, and identifying suspicious traffic.</p>\n\n<p><strong>Basic usage</strong>:</p>\n<pre><code>sudo tcpdump -i eth0</code></pre>\n\n<p><strong>Common useful flags</strong></p>\n<ul>\n  <li><code>-i &lt;iface&gt;</code>: Select network interface (e.g., <code>eth0</code>, <code>wlan0</code>, <code>any</code> for all).</li>\n  <li><code>-n</code>: Don't resolve hostnames (speeds output and avoids DNS noise).</li>\n  <li><code>-nn</code>: Don’t resolve hostnames or port names (shows numeric ports).</li>\n  <li><code>-v</code>, <code>-vv</code>, <code>-vvv</code>: Increase verbosity (more packet details).</li>\n  <li><code>-c &lt;count&gt;</code>: Capture &lt;count&gt; packets then exit (useful for quick checks).</li>\n  <li><code>-s &lt;snaplen&gt;</code>: Capture snap length (default may truncate); use <code>-s 0</code> to capture full packets.</li>\n  <li><code>-w &lt;file.pcap&gt;</code>: Write raw packets to a file for later analysis with Wireshark (<code>-w</code> is binary, no stdout).</li>\n  <li><code>-r &lt;file.pcap&gt;</code>: Read packets from a pcap file.</li>\n  <li><code>host/port</code> filters and boolean expressions: e.g., <code>tcpdump -i eth0 port 80</code>, <code>tcpdump -i eth0 tcp and src host 10.0.0.1 and dst port 22</code>.</li>\n</ul>\n\n<p><strong>Examples</strong></p>\n<pre><code># Capture 100 packets on interface eth0 without name resolution\nsudo tcpdump -i eth0 -nn -c 100\n\n# Save full packets to file for Wireshark\nsudo tcpdump -i eth0 -s 0 -w /tmp/capture.pcap\n\n# Capture only TCP traffic to port 443\nsudo tcpdump -i any -nn 'tcp port 443'\n\n# Show HTTP requests (port 80) with verbose output\nsudo tcpdump -i eth0 -A -s 0 'tcp port 80'</code></pre>\n\n<p><strong>Notes & tips</strong></p>\n<ul>\n  <li>Be careful with <code>-i any</code> and high traffic links — large captures can fill disk. Prefer filters to limit capture volume.</li>\n  <li>Use <code>-s 0</code> if you need entire packet payloads (default snaplen may truncate payloads).</li>\n  <li>Combine with <code>tcpdump -w</code> and then analyze with Wireshark for GUI inspection and protocol‑level analysis.</li>\n  <li>Run as root (sudo) or with capabilities (<code>sudo setcap 'cap_net_raw,cap_net_admin+eip' $(which tcpdump)</code>) to avoid running as root.</li>\n</ul>",
    "grade": 0
  },
  {
    "topic": "iptables — basic packet filtering and NAT",
    "category": "System / Network Admin",
    "answer": "<p><strong>iptables</strong> is the classic Linux tool for configuring netfilter packet filtering rules (firewall) and NAT. It manages tables of chains: <code>filter</code> (default, for ACCEPT/DROP), <code>nat</code> (for address translation), and <code>mangle</code> (for packet alteration).</p>\n\n<p><strong>Key concepts</strong></p>\n<ul>\n  <li><strong>Tables</strong>: <code>filter</code> (INPUT, FORWARD, OUTPUT), <code>nat</code> (PREROUTING, POSTROUTING, OUTPUT), <code>mangle</code>, etc.</li>\n  <li><strong>Chains</strong>: Ordered lists of rules (packets traverse chains in order).</li>\n  <li><strong>Targets</strong>: Actions for matching rules, e.g., <code>ACCEPT</code>, <code>DROP</code>, <code>REJECT</code>, <code>MASQUERADE</code>, <code>DNAT</code>.</li>\n</ul>\n\n<p><strong>Common commands & flags</strong></p>\n<ul>\n  <li><code>sudo iptables -L -v -n</code>: List all filter rules verbosely and numeric (no DNS/port names).</li>\n  <li><code>sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT</code>: Append rule to INPUT to accept TCP on port 22 (SSH).</li>\n  <li><code>sudo iptables -I INPUT 1 -p tcp --dport 22 -j ACCEPT</code>: Insert rule at top of INPUT chain.</li>\n  <li><code>sudo iptables -D INPUT -p tcp --dport 22 -j ACCEPT</code>: Delete a matching rule.</li>\n  <li><code>sudo iptables -P INPUT DROP</code>: Set default policy for INPUT chain to DROP (be careful — lockout risk!).</li>\n  <li><code>sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</code>: Enable basic NAT (outbound masquerading) for interface <code>eth0</code>.</li>\n  <li><code>-s &lt;source&gt;</code> and <code>-d &lt;dest&gt;</code>: Match source/destination addresses.</li>\n  <li><code>-m state --state ESTABLISHED,RELATED</code>: Match conntrack state (useful for allowing established return traffic).</li>\n</ul>\n\n<p><strong>Example: simple secure host firewall</strong></p>\n<pre><code># Flush rules\nsudo iptables -F\n\n# Default deny all inbound, allow outbound\nsudo iptables -P INPUT DROP\nsudo iptables -P FORWARD DROP\nsudo iptables -P OUTPUT ACCEPT\n\n# Allow loopback\nsudo iptables -A INPUT -i lo -j ACCEPT\n\n# Allow established/related\nsudo iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH\nsudo iptables -A INPUT -p tcp --dport 22 -m state --state NEW -j ACCEPT\n\n# Allow HTTP/HTTPS\nsudo iptables -A INPUT -p tcp --dport 80 -m state --state NEW -j ACCEPT\nsudo iptables -A INPUT -p tcp --dport 443 -m state --state NEW -j ACCEPT\n</code></pre>\n\n<p><strong>Persistence</strong>: Changes via <code>iptables</code> are not persistent across reboots by default. Use <code>iptables-save</code>/<code>iptables-restore</code>, distribution services (iptables-persistent), or migrate to <code>nftables</code> for modern replacements.</p>\n\n<p><strong>Notes</strong>: Always test firewall rules on a console session before applying remote changes (to avoid lockout). For new systems prefer <code>nftables</code> as the successor to iptables, but many production environments still use iptables tooling and wrappers.</p>",
    "grade": 0
  }
]
